package sqli

import(

	"strconv"
	"net/http"

	"github.com/julienschmidt/httprouter"

	"govwa/util/middleware"
	"govwa/util"


)

type SQLI struct{}

func New()SQLI{
	return SQLI{}
}

func (self SQLI)SetRouter(r *httprouter.Router){
	mw := middleware.New()
	r.GET("/sqli1", mw.CapturePanic(mw.AuthCheck(sqli1Handler)))
}

func sqli1Handler(w http.ResponseWriter, r *http.Request, _ httprouter.Params){

	uid := util.GetCookie(r,"Uid")//many developer use this style set reference key in cookie with no sanitaze
	p := newProfile()

	data := make(map[string]interface{})

	err := p.unsafeQueryGetData(uid)

	if err != nil{
		data["error"] = err.Error()
	}
	data["uid"] = strconv.Itoa(p.Uid)
	data["name"] = p.Name
	data["city"] = p.City
	data["number"] = p.PhoneNumber

	util.SafeRender(w,"template.sqli",data)

}
/* func UnsafeGetData(r *http.Request)(User, error){
	db, err := database.Connect()
	if err != nil{
		return User{},err
	}
	defer db.Close()
	//get data from clien
	uid := r.URL.Query().Get("uid")
	sql := fmt.Sprintf("SELECT * FROM users where id=%s",uid) //unsafe query. will cause big sql injection attack
	rows, err := db.Query(sql)
	if err != nil{
		return User{}, err
	}
	defer rows.Close()
	//var data []User
	var user = User{}
	for rows.Next(){
		err = rows.Scan(&user.Id, &user.Name)
		if err != nil{
			return User{}, err
		}
	}
	return user,nil

}
func SafeGetData(r *http.Request)(User, error){
	db, err := database.Connect()
	if err != nil{
		return User{},err
	}
	defer db.Close()
	//get data from clien
	uid := r.URL.Query().Get("uid")
	sql := fmt.Sprintf("SELECT * FROM users where id=?") //set safe query

	stmtOut, err := db.Prepare(sql) //prepare statement 
	if err != nil{
		return User{}, err
	}
	defer stmtOut.Close()
	var user = User{}
	err = stmtOut.QueryRow(uid).Scan(&user.Id, &user.Name)
	if err != nil{
		return User{}, err
	}
	return user,nil

}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
	data, err := UnsafeGetData(r) //default function set to unsafe
	if util.CheckLevel(r) {            //if level == high
		data, err = SafeGetData(r)
	}
	if err != nil {
		fmt.Println(err.Error())
	}
	util.RenderAsJson(w, data)
} */